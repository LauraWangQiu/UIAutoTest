import subprocess
import threading
from src.graphsDef import Graph

"""
    This class is used to run a selected executable in a secondary thread and generate a graph of the execution
    flow. The graph is generated by iterating over the nodes and adding them to the graph.
    The class is designed to be inherited by other classes that will implement the on_graph_step method to
    retain the information about the graph.
"""
class Test:
    def __init__(self, name, selected_executable=None):
        self.name = name
        self.selected_executable = selected_executable
        self.thread = None
        self.graph = Graph()
        self.node_inputs = []
        self.delay_ms = 1000
        print(f"Initializing {self.name} class")

    """
        Calls the callback function after a delay in milliseconds.
    """
    def after(self, delay_ms, callback):
        delay_seconds = delay_ms / 1000.0
        timer = threading.Timer(delay_seconds, callback)
        timer.start()

    """
        Simply debugs the name of the class and generates the graph.
    """
    def run(self):
        print(f"Running {self.name}")
        self.generate_graph()

    """
        Generates the graph by running the selected executable in a secondary thread.
        If the graph is already generated, it will not generate it again.
    """
    def generate_graph(self):
        print(f"{self.name}: Generating graph for {self.selected_executable}")
        # TODO: Save the current state of the executable in case of a crash or being on a leaf node

        # Run for the first time
        self.start_executable_in_thread()
        self.after(self.delay_ms, self.loop)

    """
        Runs the selected executable in a secondary thread.
    """
    def start_executable_in_thread(self):
        """
            Runs the selected executable.
        """
        def start_executable():
            try:
                print(f"Starting executable: {self.selected_executable}")
                self.process = subprocess.Popen([self.selected_executable])
            except FileNotFoundError:
                print(f"Executable not found: {self.selected_executable}")
                self.process = None

        self.thread = threading.Thread(target=start_executable, daemon=True)
        self.thread.start()

    """
        Iterates over the nodes in the graph and adds them to the graph.
    """
    def loop(self):
        print(f"{self.name}: Looping through the graph")
        # TODO: Connect with Sikulix wrapper to consider start node and iterate over the inputs
        # adding nodes and edges to the graph and calling the on_graph_step method
        # so that children classes can retain the information about the graph
        # on_graph_step(node) or on_graph_step(transition)

    """
        To be implemented by the child classes.
    """
    def on_graph_step(self, element):
        pass
